package org.foomo.zugspitze.services.rpc
{
	import flash.events.Event;
	import flash.events.EventDispatcher;
	import flash.events.IOErrorEvent;
	import flash.events.ProgressEvent;
	import flash.events.SecurityErrorEvent;

	import org.foomo.zugspitze.services.rpc.events.RPCMethodCallTokenEvent;
	import org.foomo.zugspitze.services.rpc.events.RPCTransportEvent;
	import org.foomo.zugspitze.services.rpc.protocol.Call;
	import org.foomo.zugspitze.services.rpc.protocol.Reply;
	import org.foomo.zugspitze.services.rpc.protocol.call.CallHead;
	import org.foomo.zugspitze.services.rpc.protocol.call.MethodCall;
	import org.foomo.zugspitze.services.rpc.protocol.reply.MethodReply;

	/**
	 * Generic client for AMF / APC services do not fiddle directly with this class use autogenerated clients
	 */
	public class RPCClient extends EventDispatcher
	{
		//-----------------------------------------------------------------------------------------
		// ~ Static variables
		//-----------------------------------------------------------------------------------------

		/**
		 * private counter for method calls
		 */
		private static var methodCallCounter:uint = 0;
		/**
		 * private counter for service calls
		 */
		private static var rpcCallCounter:uint = 0;

		//-----------------------------------------------------------------------------------------
		// ~ Variables
		//-----------------------------------------------------------------------------------------

		/**
		 * the active call - will be reset, as soon as the results have been received and dispatched to their listeners
		 */
		public var currentCall:Call;
		/**
		 * means of transportation
		 */
		protected var transport:RPCTransport;
		/**
		 * all the active tokens are stored here, until the method replies are extracted from the server reply and dispatched to their listeners
		 */
		protected var tokens:Object;
		/**
		 * name of the class exposed on the server side
		 */
		protected var serviceClassName:String;
		/**
		 * version of the client
		 */
		protected var serviceClassVersion:Number;
		/**
		 * session id for the service
		 */
		protected var serviceSessionId:String;
		/**
		 * where to connect to
		 */
		protected var _endPoint:String;

		//-----------------------------------------------------------------------------------------
		// ~ Constructor
		//-----------------------------------------------------------------------------------------

		public function RPCClient(endPoint:String, serviceClassName:String, serviceClassVersion:Number, serviceSessionId:String = null)
		{
			super();
			this.serviceClassName = serviceClassName;
			this.serviceClassVersion = serviceClassVersion;
			this.serviceSessionId = serviceSessionId;
			this.tokens = new Object;
			this.endPoint = endPoint;
			this.resetCall();
		}

		//-----------------------------------------------------------------------------------------
		// ~ Public methods
		//-----------------------------------------------------------------------------------------

		/**
		 * Set new end point
		 */
		public function set endPoint(value:String):void
		{
			this._endPoint = value;
		}
		public function get endPoint():String
		{
			return this._endPoint
		}

		/**
		 * be aware, that you can add multiple methods to a call and send them at once with sendCall()
		 */
		public function addMethodCall(methodName:String, arguments:Array):RPCMethodCallToken
		{
			var methodCall:MethodCall = new MethodCall;
			methodCall.method = methodName;
			methodCall.arguments = arguments;
			methodCall.id = 'mc-' + (methodCallCounter++);
			var token:RPCMethodCallToken = new RPCMethodCallToken;
			token.methodCallId = methodCall.id;
			this.tokens[methodCall.id] = token;
			this.currentCall.calls.push(methodCall);
			return token;
		}

		/**
		 * send the call - depending on how many methodCalls you added, this will result in multiple method calls on the server
		 */
		public function sendCall():RPCTransport
		{
			var transport:RPCTransport = new RPCTransport(this._endPoint);
			this.addTransportEventListeners(transport);
			transport.send(this.currentCall);
			this.resetCall();
			return transport;
		}

		//-----------------------------------------------------------------------------------------
		// ~ Private Eventhandler
		//-----------------------------------------------------------------------------------------

		/**
		 *
		 */
		private function transport_completeHandler(event:Event):void
		{
			var transport:RPCTransport = RPCTransport(event.target);
			this.removeTransportEventListeners(transport);
			var reply:Reply = transport.readReply();

			for (var i:int=0; i<reply.methodReplies.length; i++) {
				var methodReply:MethodReply = MethodReply(reply.methodReplies[i]);
				var token:RPCMethodCallToken = RPCMethodCallToken(this.tokens[methodReply.id]);
				token.dispatchEvent(new RPCMethodCallTokenEvent(RPCMethodCallTokenEvent.METHOD_CALL_TOKEN_COMPLETE, methodReply, null));
				delete this.tokens[methodReply.id]
			}
		}

		/**
		 *
		 */
		private function transport_errorHandler(event:Event):void
		{
			var transport:RPCTransport = RPCTransport(event.target);
			this.removeTransportEventListeners(transport);

			var failedRequest:Call = Call(transport.data);
			for (var i:int=0; i<failedRequest.calls.length; i++) {
				var failedMethodCall:MethodCall = MethodCall(failedRequest.calls[i]);
				var token:RPCMethodCallToken = RPCMethodCallToken(this.tokens[failedMethodCall.id]);
				token.dispatchEvent(new RPCMethodCallTokenEvent(RPCMethodCallTokenEvent.METHOD_CALL_TOKEN_ERROR, null, failedMethodCall));
				delete this.tokens[failedMethodCall.id]
			}
		}

		//-----------------------------------------------------------------------------------------
		// ~ Private methods
		//-----------------------------------------------------------------------------------------

		/**
		 *
		 */
		private function addTransportEventListeners(transport:RPCTransport):void
		{
			transport.addEventListener(Event.COMPLETE, this.transport_completeHandler);
			transport.addEventListener(IOErrorEvent.IO_ERROR, this.transport_errorHandler);
			transport.addEventListener(IOErrorEvent.NETWORK_ERROR, this.transport_errorHandler);
			transport.addEventListener(SecurityErrorEvent.SECURITY_ERROR, this.transport_errorHandler);
		}

		/**
		 *
		 */
		private function removeTransportEventListeners(transport:RPCTransport):void
		{
			transport.removeEventListener(Event.COMPLETE, this.transport_completeHandler);
			transport.removeEventListener(IOErrorEvent.IO_ERROR, this.transport_errorHandler);
			transport.removeEventListener(IOErrorEvent.NETWORK_ERROR, this.transport_errorHandler);
			transport.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, this.transport_errorHandler);
		}

		/**
		 *
		 */
		private function resetCall():void
		{
			this.currentCall = new Call;
			this.currentCall.head = new CallHead;
			this.currentCall.head.className = this.serviceClassName;
			this.currentCall.head.classVersion = this.serviceClassVersion;
			this.currentCall.head.sessionId = this.serviceSessionId;
			this.currentCall.head.callId = 'cc-' + (rpcCallCounter++);
		}
	}
}