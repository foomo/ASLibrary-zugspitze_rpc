package org.foomo.zugspitze.services.core.rpc
{
	import flash.events.Event;
	import flash.events.EventDispatcher;
	import flash.events.IOErrorEvent;
	import flash.events.ProgressEvent;
	import flash.events.SecurityErrorEvent;

	import org.foomo.zugspitze.services.core.rpc.events.RPCClientErrorEvent;
	import org.foomo.zugspitze.services.core.rpc.events.RPCClientEvent;
	import org.foomo.zugspitze.services.core.rpc.events.RPCMethodCallEvent;
	import org.foomo.zugspitze.services.core.rpc.events.RPCTransportErrorEvent;
	import org.foomo.zugspitze.services.core.rpc.protocol.Call;
	import org.foomo.zugspitze.services.core.rpc.protocol.Reply;
	import org.foomo.zugspitze.services.core.rpc.protocol.call.CallHead;
	import org.foomo.zugspitze.services.core.rpc.protocol.call.MethodCall;
	import org.foomo.zugspitze.services.core.rpc.protocol.reply.MethodReply;

	[Event(name="ioError", type="org.foomo.zugspitze.services.core.rpc.events.RPCClientErrorEvent")]
	[Event(name="securityError", type="org.foomo.zugspitze.services.core.rpc.events.RPCClientErrorEvent")]
	[Event(name="rpcTransportError", type="org.foomo.zugspitze.services.core.rpc.events.RPCClientErrorEvent")]
	[Event(name="rpcTransportComplete", type="org.foomo.zugspitze.services.core.rpc.events.RPCClientEvent")]
	[Event(name="rpcTransportProgress", type="org.foomo.zugspitze.services.core.rpc.events.RPCClientEvent")]
	[Event(name="rpcTransportOpen", type="org.foomo.zugspitze.services.core.rpc.events.RPCClientEvent")]

	/**
	 * Generic client for AMF / APC services do not fiddle directly with this class use autogenerated clients
	 */
	public class RPCClient extends EventDispatcher
	{
		//-----------------------------------------------------------------------------------------
		// ~ Static variables
		//-----------------------------------------------------------------------------------------

		/**
		 * private counter for method calls
		 */
		private static var methodCallCounter:uint = 0;
		/**
		 * private counter for service calls
		 */
		private static var rpcCallCounter:uint = 0;

		//-----------------------------------------------------------------------------------------
		// ~ Variables
		//-----------------------------------------------------------------------------------------

		/**
		 * the active call - will be reset, as soon as the results have been received and dispatched to their listeners
		 */
		public var currentCall:Call;
		/**
		 * means of transportation
		 */
		protected var transport:RPCTransport;
		/**
		 * all the active tokens are stored here, until the method replies are extracted from the server reply and dispatched to their listeners
		 */
		protected var tokens:Object;
		/**
		 * name of the class exposed on the server side
		 */
		protected var serviceClassName:String;
		/**
		 * version of the client
		 */
		protected var serviceClassVersion:Number;
		/**
		 * session id for the service
		 */
		protected var serviceSessionId:String;
		/**
		 * where to connect to
		 */
		protected var _endPoint:String;

		//-----------------------------------------------------------------------------------------
		// ~ Constructor
		//-----------------------------------------------------------------------------------------

		public function RPCClient(endPoint:String, serviceClassName:String, serviceClassVersion:Number, serviceSessionId:String = null)
		{
			super();
			this.serviceClassName = serviceClassName;
			this.serviceClassVersion = serviceClassVersion;
			this.serviceSessionId = serviceSessionId;
			this.tokens = new Object;
			this.endPoint = endPoint;
			this.resetCall();
		}

		//-----------------------------------------------------------------------------------------
		// ~ Public methods
		//-----------------------------------------------------------------------------------------

		/**
		 * Set new end point
		 */
		public function set endPoint(value:String):void
		{
			this._endPoint = value;
		}
		public function get endPoint():String
		{
			return this._endPoint
		}

		/**
		 * be aware, that you can add multiple methods to a call and send them at once with sendCall()
		 */
		public function addMethodCall(methodName:String, arguments:Array):RPCMethodCallToken
		{
			var methodCall:MethodCall = new MethodCall;
			methodCall.method = methodName;
			methodCall.arguments = arguments;
			methodCall.id = 'mc-' + (methodCallCounter++);
			var token:RPCMethodCallToken = new RPCMethodCallToken;
			token.methodCallId = methodCall.id;
			this.tokens[methodCall.id] = token;
			this.currentCall.calls.push(methodCall);
			return token;
		}

		/**
		 * send the call - depending on how many methodCalls you added, this will result in multiple method calls on the server
		 */
		public function sendCall():RPCTransport
		{
			var transport:RPCTransport = new RPCTransport(this._endPoint);
			this.addTransportEventListeners(transport);
			transport.send(this.currentCall);
			this.resetCall();
			return transport;
		}

		//-----------------------------------------------------------------------------------------
		// ~ Protected Eventhandler
		//-----------------------------------------------------------------------------------------

		/**
		 *
		 */
		protected function transport_openHandler(event:Event):void
		{
			var transport:RPCTransport = RPCTransport(event.target);

			var failedRequest:Call = Call(transport.data);
			for (var i:int=0; i<failedRequest.calls.length; i++) {
				var failedMethodCall:MethodCall = MethodCall(failedRequest.calls[i]);
				var token:RPCMethodCallToken = RPCMethodCallToken(this.tokens[failedMethodCall.id]);
				token.dispatchEvent(event);
			}

			this.dispatchEvent(new RPCClientEvent(RPCClientEvent.RPC_TRANSPORT_OPEN, transport));
		}

		/**
		 *
		 */
		protected function transport_progressHandler(event:ProgressEvent):void
		{
			var transport:RPCTransport = RPCTransport(event.target);

			var failedRequest:Call = Call(transport.data);
			for (var i:int=0; i<failedRequest.calls.length; i++) {
				var failedMethodCall:MethodCall = MethodCall(failedRequest.calls[i]);
				var token:RPCMethodCallToken = RPCMethodCallToken(this.tokens[failedMethodCall.id]);
				token.dispatchEvent(event);
			}

			this.dispatchEvent(new RPCClientEvent(RPCClientEvent.RPC_TRANSPORT_PROGRESS, transport));
		}

		/**
		 *
		 */
		protected function transport_completeHandler(event:Event):void
		{
			var transport:RPCTransport = RPCTransport(event.target);
			this.removeTransportEventListeners(transport);

			var reply:Reply = transport.reply;
			var request:Call = Call(transport.data);
			var requestMethodCalls:Array = new Array;

			for each (var methodCall:MethodCall in request.calls)  {
				requestMethodCalls[methodCall.id] = methodCall;
			}

			for (var i:int=0; i<reply.methodReplies.length; i++) {
				var methodReply:MethodReply = MethodReply(reply.methodReplies[i]);
				var token:RPCMethodCallToken = RPCMethodCallToken(this.tokens[methodReply.id]);
				token.dispatchEvent(new RPCMethodCallEvent(RPCMethodCallEvent.RPC_METHOD_CALL_COMPLETE, requestMethodCalls[methodReply.id], methodReply));
				delete this.tokens[methodReply.id]
			}

			this.dispatchEvent(new RPCClientEvent(RPCClientEvent.RPC_TRANSPORT_COMPLETE, transport));
		}

		/**
		 *
		 */
		protected function transport_errorHandler(event:Event):void
		{
			var transport:RPCTransport = RPCTransport(event.target);
			this.removeTransportEventListeners(transport);

			var failedRequest:Call = Call(transport.data);
			for (var i:int=0; i<failedRequest.calls.length; i++) {
				var failedMethodCall:MethodCall = MethodCall(failedRequest.calls[i]);
				var token:RPCMethodCallToken = RPCMethodCallToken(this.tokens[failedMethodCall.id]);
				token.dispatchEvent(new RPCMethodCallEvent(RPCMethodCallEvent.RPC_METHOD_CALL_ERROR, failedMethodCall));
				delete this.tokens[failedMethodCall.id]
			}

			switch (event.type) {
				case IOErrorEvent.IO_ERROR:
					this.dispatchEvent(new RPCClientErrorEvent(RPCClientErrorEvent.IO_ERROR, transport, event['text'], event['errorID']));
					break;
				case SecurityErrorEvent.SECURITY_ERROR:
					this.dispatchEvent(new RPCClientErrorEvent(RPCClientErrorEvent.SECURITY_ERROR, transport, event['text'], event['errorID']));
					break;
				default:
					this.dispatchEvent(new RPCClientErrorEvent(RPCClientErrorEvent.RPC_TRANSPORT_ERROR, transport, event['text'], event['errorID']));
					break;
			}
		}

		//-----------------------------------------------------------------------------------------
		// ~ Private methods
		//-----------------------------------------------------------------------------------------

		/**
		 *
		 */
		private function addTransportEventListeners(transport:RPCTransport):void
		{
			transport.addEventListener(Event.OPEN, this.transport_openHandler);
			transport.addEventListener(Event.COMPLETE, this.transport_completeHandler);
			transport.addEventListener(IOErrorEvent.IO_ERROR, this.transport_errorHandler);
			transport.addEventListener(ProgressEvent.PROGRESS, this.transport_progressHandler);
			transport.addEventListener(RPCTransportErrorEvent.NULL_ERROR, this.transport_errorHandler);
			transport.addEventListener(RPCTransportErrorEvent.REPLY_ERROR, this.transport_errorHandler);
			transport.addEventListener(SecurityErrorEvent.SECURITY_ERROR, this.transport_errorHandler);
		}

		/**
		 *
		 */
		private function removeTransportEventListeners(transport:RPCTransport):void
		{
			transport.removeEventListener(Event.OPEN, this.transport_openHandler);
			transport.removeEventListener(Event.COMPLETE, this.transport_completeHandler);
			transport.removeEventListener(IOErrorEvent.IO_ERROR, this.transport_errorHandler);
			transport.removeEventListener(ProgressEvent.PROGRESS, this.transport_progressHandler);
			transport.removeEventListener(RPCTransportErrorEvent.NULL_ERROR, this.transport_errorHandler);
			transport.removeEventListener(RPCTransportErrorEvent.REPLY_ERROR, this.transport_errorHandler);
			transport.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, this.transport_errorHandler);
		}

		/**
		 *
		 */
		private function resetCall():void
		{
			this.currentCall = new Call;
			this.currentCall.head = new CallHead;
			this.currentCall.head.className = this.serviceClassName;
			this.currentCall.head.classVersion = this.serviceClassVersion;
			this.currentCall.head.sessionId = this.serviceSessionId;
			this.currentCall.head.callId = 'cc-' + (rpcCallCounter++);
		}
	}
}